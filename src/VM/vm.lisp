(require "instructions.lisp")
(load "src/compilation/compiler.lisp")
;; Registres : R0, R1, R2, BP, SP, PC, FP (General Register R0, R1 and R2)
;; (SP Stack Pointer) (PC) (FP Frame Pointer)
;; Flags : FLT, FEQ, FGT (Flag less than, Flag equal, Flag greater than) 

;; Creation de la VM
(defun vm_make (&optional (vm_name 'MY_VM) (memory_size 1000000))
  (setf (get vm_name :vm_name) vm_name)
  (setf (get vm_name :R0) 0)
  (setf (get vm_name :R1) 0)
  (setf (get vm_name :R2) 0)
  (setf (get vm_name :SP) 303)
  (setf (get vm_name :PC) 700000)
  (setf (get vm_name :FP) 300)
  (setf (get vm_name :FLT) 0)
  (setf (get vm_name :FEQ) 0)
  (setf (get vm_name :FGT) 0)
  (setf (get vm_name :MEMORY) (make-array memory_size :initial-element nil))
  (setf (get vm_name :exitVM) 0)
  (vm_set_mem vm_name 0  '((BP . 1) (MAX_STACK . 2) (START_CODE . 3) (LAST_CODE . 4) (MAX_MEM . 5) (LABELS . 6)))
  (vm_set_mem vm_name (vm_get_low_variable vm_name 'BP) 300)
  (vm_set_mem vm_name (vm_get_low_variable vm_name 'MAX_STACK) 999999)
  (vm_set_mem vm_name (vm_get_low_variable vm_name 'LABELS) (make-hash-table))
  (vm_set_mem vm_name (vm_get_low_variable vm_name 'START_CODE) (get vm_name :PC))
  (vm_set_mem vm_name (vm_get_low_variable vm_name 'LAST_CODE) (get vm_name :PC))

  
  (format t "~%Initialisation de la VM : ~a~%" vm_name)
  vm_name
)


(defun vm_exec_jne (vm_name adr)
  (if (not (vm_get_reg vm_name :DEQ))
    (vm_set_reg vm_name 'PC adr)
  )
)


;; Éxécution
(defun vm_exec (vm_name)
  (let ((start-time (get-internal-real-time))
  (end-time nil))
  (loop while (eq (get vm_name :exitVM) 0) do (progn                                    
    (sleep 0)                                         
    (if (not (atom (vm_get_mem vm_name (vm_get_reg vm_name :PC))))
        (let* ((row (vm_get_mem vm_name (vm_get_reg vm_name :PC)))
               (fun (car row))
               (arg1 (cadr row))
               (arg2 (caddr row)))
          (cond 
            ((eq fun 'LOAD)
             (vm-load vm_name arg1 arg2))
            ((eq fun 'STORE)
             (vm-store vm_name arg1 arg2))
            ((eq fun 'MOVE)
             (vm-move vm_name arg1 arg2))
            ((eq fun 'ADD)
             (vm-add vm_name arg1 arg2))
            ((eq fun 'SUB)
             (vm-sub vm_name arg1 arg2))
            ((eq fun 'MULT)
             (vm-mul vm_name arg1 arg2))
            ((eq fun 'DIV) 
             (vm-div vm_name arg1 arg2))
            ((eq fun 'INCR)
             (vm-incr vm_name arg1))
            ((eq fun 'DECR)
             (vm-decr vm_name arg1))
            ((eq fun 'PUSH)
             (vm-push vm_name arg1))
            ((eq fun 'POP)
             (vm-pop vm_name arg1))
            ((eq fun 'LABEL) 
             (vm-exec-label vm_name))
            ((eq fun 'JMP)
             (vm-jump vm_name arg1))
            ((eq fun 'JSR)
             (vm-jump-retour vm_name arg1))
            ((eq fun 'RTN)
             (vm-rtn vm_name))
            ((eq fun 'CMP)
               (vm-cmp vm_name arg1 arg2))
            ((eq fun 'JGT)
             (vm-jgt vm_name arg1))
            ((eq fun 'JGE) 
             (vm-jge vm_name arg1))
            ((eq fun 'JLT) 
             (vm-jlt vm_name arg1))
            ((eq fun 'JLE)
             (vm-jle vm_name arg1))
            ((eq fun 'JEQ) 
             (vm-jeq vm_name arg1))
            ((eq fun 'JNE) 
             (vm-jne vm_name arg1))
            ((eq fun 'FENTRY)
             (vm-nop vm_name))
            ((eq fun 'FEXIT)
             (vm-nop vm_name))
            ((eq fun 'HALT)
             (progn                
               (vm-halt vm_name)
              ))
            (t 
             (if (functionp fun)
                 (funcall fun arg1))))
          (vm-incr vm_name :PC)
      )))
    )
  (setf end-time (get-internal-real-time))
  (format t "~%Le temps d'exécution total est de ~,2F secondes.~%" (/ (- end-time start-time) internal-time-units-per-second)
  (setf (get vm_name :exitVM) 1))
  )
)

;; Charge Code
(defun vm_load (vm_name code-list)
  (let* ((taille (length code-list)))
    (loop for i from 0 below taille do
      (let* ((old_code (vm_get_mem vm_name (vm_get_low_variable vm_name 'LAST_CODE)))
           (adr (+ 1 old_code)))
        (vm_set_mem vm_name old_code (elt code-list i))
        (vm_set_low_variable vm_name 'LAST_CODE adr)
        (if (eq (car (elt code-list i)) 'LABEL)
          (let ((hashmap (vm_get_mem vm_name (vm_get_low_variable vm_name 'LABELS))))
            (vm_set_label vm_name (cadr (elt code-list i)) old_code)
          )
        )
      )
    )
  )
  (vm_get_mem vm_name (vm_get_low_variable vm_name 'LABELS))
  (format t "~%Chargement du code dans ~a terminé.~%" vm_name)
)

;; Charge Fichier de Code
(defun vm_load_file (vm_name file) ;; file est écrit en ASSEMBLEUR mais en Lisp donc sous forme de liste
  (let ((program-lines '()))
    (with-open-file (stream file :direction :input)
      (loop for line = (read-line stream nil)
        while line
        do (let ((expression (ignore-errors (read-from-string line))))
              (if expression
                  (setq program-lines (append program-lines (list expression))) ;; ajoute à la fin de la liste
              )
            ) 
      )
    )
    (vm_load vm_name program-lines)
  )
)

(defun vm_CL (vm_name codeLisp) ;; Compile & Charge
  (vm_load vm_name (compile codeLisp))
)

(defun vm_CLE (vm_name codeLisp) ;; Compile & Charge & Éxecute
  (vm_CL vm_name codeLisp)
  (vm_exec vm_name)
)
